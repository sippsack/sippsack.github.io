bio: Falk Sippach hat über 20 Jahre Erfahrung mit Java und ist bei der Mannheimer Firma OIO Orientation in Objects GmbH als Trainer und Software-Entwickler/Architekt tätig. Er publiziert regelmäßig in Blogs, Fachartikeln und auf Konferenzen. In seiner Wahlheimat Darmstadt organisiert er mit Anderen die örtliche Java User Group. Falk twittert unter @sippsack.  
bio_en: Falk Sippach has over 20 years of experience with Java and works for the Mannheim-based company OIO Orientation in Objects GmbH as a trainer and software developer/architect. He regularly publishes in blogs, professional articles and at conferences. In his adopted home Darmstadt he organizes the local Java User Group together with others. Falk twitters under @sippsack.
links:
  Homepage: http://www.sippsack.de
  Blog: https://blog.oio.de/author/sippsack/
  Twitter: https://twitter.com/sippsack
  GitHub: https://github.com/sippsack
  Xing: https://www.xing.com/profile/Falk_Sippach
  LinkedIn: https://www.linkedin.com/in/falk-sippach-845259114/
photos:
  "400 px": /images/falk_sippach-400px.jpg
  "300 dpi": /images/falk_sippach-300dpi.jpg
activities: 
  - event: Java User Group Darmstadt
    activity: Co-Organisator
    link: http://www.jug-da.de/about/
    since: 2013
  - event: Javaland
    activity: Programmkomitee 
    link: http://www.javaland.eu/
    since: 2013
  - event: Entwicklertag Frankfurt
    activity: Unterstützung Programmbeirat 
    link: https://entwicklertag.de
    since: 2014
  - event: DukeCon
    activity: Mitgründer und Comitter 
    link: http://dukecon.org/
    since: 2015
  - event: Herbstcampus
    activity: Programmkomitee 
    link: https://www.herbstcampus.de/konferenz_programmkomitee.php
    since: 2016
  - event: JAX
    activity: Mitglied im Advisory Board
    link: http://www.jax.de/
    since: 2016
  - event: IT-Tage
    activity: Mitglied im Kuratorium
    link: https://www.ittage.informatik-aktuell.de/konferenz/kuratorium/
    since: 2017
  - event: OOP
    activity: Bewerter für die Einreichungen
    link: https://www.oop-konferenz.de/oop2019/programm/reviewer.html
    since: 2018
talks:
  current:
    "Legacy Code meistern in x einfachen Schritten": |
      In einer idealen Welt würden wir nur "neuen" Code schreiben, der natürlich perfekt und wunderschön ist. Wir müßten nie wieder unseren Code anschauen geschweige denn 10 Jahre alte Projekte warten. Ende des Tagtraums ... 
      <br/><br/>
      Leider ist unsere Welt nicht so ideal, unser Code von gestern ist heute schon Legacy. Diesen im Nachhinein zu verstehen, zu erweitern oder darin Fehler zu beheben ist immer eine Herausforderung, insbesondere wenn Tests fehlen.Trotzdem gibt es einfache Möglichkeiten, wie man die Qualität von Legacy Code verbessern kann. Das Wichtigste ist das Einziehen von Fangnetzen, so daß man trotz fehlender Tests guten Gewissens Änderungen durchführen kann. Wer Golden Master, Subclass to Test und Extract Pure Functions an konkreten Beispielen kennenlernen möchte, ist in dieser Session genau richtig.
    "TDLCR - Test Driven Legacy Code Refactoring": |
      Bestandsanwendungen müssen gewartet und ggf. weiterentwickelt werden, bergen aber meist viele Defekte. Als Entwickler fürchten wir uns zudem, mehr Schaden anzurichten, weil das Verständnis für den Legacy Code fehlt. Refactoring kann zum Verstehen beitragen, endet aber aufgrund der typischerweise fehlenden automatisierten Tests in einem Blindflug.
      <br/><br/>
      Mit testgetriebener Entwicklung scheint es eine Allzweckwaffe für gutes Design und eine geringe Fehlerrate zu geben. Aber TDD und Legacy Code schließen sich eigentlich aus. Anhand von Live Coding schauen wir, wie die testgetriebene Entwicklung trotzdem helfen kann, den Code ohne allzu große Bauchschmerzen anzupassen. Schöner Nebeneffekt wird das Entstehen eines automatisierten Testbetts sein, welches zukünftige Refactorings leichter macht.    
    "Kontinuierliche Architekturdokumentation im agilen Umfeld": |
      Man kann zwar an vielen Stellen nachlesen, wie man Architekturdokumentation strukturiert. Aber auf der Suche nach einer praktikablen Handhabung zur Erstellung und Pflege enden die meisten Versuche in der WYSIWYG-Hölle einer Textverarbeitung oder im tiefen Schlund eines Wikis. In diesem Vortrag wollen wir uns anschauen, wie aufbauend auf bestehenden Tools und Textformaten eine möglichst redundanzfreie Dokumentation erstellt und für verschiedene Zielgruppen in ansprechenden Formaten ausgeliefert werden kann. Es wird dabei um Begriffe wie Continuous Documentation und Documentation as Code gehen.
    "JVM Functional Language Battle": |
      Funktionale Programmierung soll so viel ausdrucksstärker sein, aber leider ist dieses Programmier-Paradigma nicht ganz kompatibel zu der prozedural- und objektorientierten Denkweise von uns Java-Entwicklern. Anhand eines kleinen Algorithmus werden wir uns verschiedene Lösungen zunächst im klassischem imperativen Java (vor Java 8) und als Vergleich dazu in alternativen JVM-Sprachen (Groovy, JavaScript, Scala und Frege/Haskell) anschauen und die verschiedenen Lösungen diskutieren. Herauskommen soll eine saubere und verständlichere Struktur, die zu besser les- und wartbarem Code führen wird.
      <br/><br/>
      Die gewonnenen Erkenntnisse wollen wir dann letztendlich in Java 8 mittels Streams und Lambda-Ausdrücken umsetzen, so dass jeder Zuhörer die Grundideen der funktionalen Programmierung mit in seine tägliche Arbeit nehmen kann. Es sind keine speziellen Vorkenntnisse in den angesprochenen alternativen Sprachen notwendig, ein solides Verständnis für die Programmiersprache Java genügt.
    "Agile Architecture (Co-Sprecher: Thorsten Maier, Orientation in Objects GmbH)": |
      Eine gut geplante Software-Architektur stellt das Grundgerüst jeder wartbaren Software dar. Dies steht in einem scheinbaren Widerspruch zu agilen Softwareprozessen, bei denen langfristige Planungen weitestgehend vermieden werden. Die Session zeigt anhand zahlreicher konkreter Beispiele, wie man die Erstellung einer Software-Architektur in einzelne Aufgabenpakete unterteilt, dokumentiert und regelmäßig durch Reviews und automatisierte Architektur-Tests verifiziert. Das Ziel ist es, auch in einem iterativen Prozess eine langfristig tragfähige Architektur entstehen zu lassen.
      <br/><br/>
      Anmerkungen fürs Programmkomitee:
      <br/><br/>
      In diesem Vortrag liefern wir praktische Tipps, wie man eine tragfähige Architektur im Rahmen iterativer Prozesse einführt, pflegt und weiterentwickelt. Wir haben dazu nach dem Verfahren "Plan, Do, Check, Act" einzelne Aspekte des Architektur-Entwurfs, -Bewertung, -Kommunikation, -Tests usw. zusammengefasst und stellen diese mit unseren Erfahrungen aus der Praxis vor.
    "PWA: Portable Webanwendungen statt nativer Apps": |
      Mobile First war gestern, Offline First heißt die neue Devise. Mit diesem Credo kommen Progressive Web Apps (PWA) nicht nur sehr nahe an native Smartphone Applikationen heran, sie erhöhen vor allem die User Experience bei fehlender oder sehr schlechter Internetverbindung und müssen nicht mehr über App Stores ausgeliefert werden. Anhand einer Beispielapplikation werden wir die Grundkonzepte wie Service Worker, Application Shell, Caching und Push Notifications diskutieren und einen Ausblick auf die mobilen Anwendungen der Zukunft werfen.
    "Docs as Code – Architekturdokumentation leicht gemacht (Co-Sprecher: Ralf D. Müller, Freiberufler)": |
      Technische Dokumentation sollte man nicht mit Textverarbeitungsprogrammen erzeugen. Stattdessen ergibt es Sinn, die Erstellung in die normalen Entwicklungsprozesse einzubeziehen, sie zu automatisieren (Continuous Documentation) und mit den typischen Werkzeugen der Entwickler sowie mittels leichtgewichtigen Textformaten zu bearbeiten (Documentation as Code).
      <br/><br/>
      Anhand einer Architekturdokumentation zeigen wir, wie Sie mit dem arc42-Template im AsciiDoc-Format und Gradle als Build-Tool einfach Diagramme in Ihre Dokumentation integrieren, Stakeholder-spezifische Dokumente erzeugen und verschiedene Ausgabeformate generieren. Reviewfähige PDF-Dokumente? Publishing nach Confluence? Integration einer Präsentation? Alles kein Problem! Einige Teile der Doku können Sie sogar automatisiert testen. Zwischendurch bekommen Sie zahlreiche Tipps, wie und wo Sie systematisch den Aufwand für Dokumentation reduzieren können und trotzdem lesbare, verständliche und praxistaugliche Ergebnisse produzieren. Dokumentieren soll endlich auch Spaß machen.
    "Vue.js - Neuer Stern am Framework-Himmel": |
      Im Schatten von Angular und React hat sich mit Vue.js ein weiteres JavaScript Webframework als ernstzunehmende Alternative zur Erstellung von modularen Single Page Applications entwickelt. Der Einstieg ist dank des einfachen und minimalen Kerns einfach, durch die hohe Anpassungsfähigkeit und das weniger dogmenbehaftete Programmiermodell bietet es aber viele Möglichkeiten für die Erstellung flexibler und performanter Webanwendungen. In diesem Vortrag werden wir am Beispiel eines Konferenzplanners die Konzepte von Vue.js diskutieren.
    "Refactoring mit der Mikado-Methode": |
      Viele von uns haben tagtäglich mit Legacy-Code zu tun. Mal eben schnell etwas umzubauen, scheitert typischerweise an den fehlenden Tests, zudem ist der Quellcode oft überhaupt schlecht testbar.
      <br/><br/>
      In diesem Vortrag wird anhand von praktischen Codebeispielen gezeigt, wie man zunächst ein automatisiertes Sicherheitsnetz aufspannt. Anschließend werden komplexere Refactorings durchgeführt, ohne jedoch zu viele Baustellen gleichzeitig aufzureißen. Die Mikado-Methode hilft dabei, den Überblick zu behalten und in möglichst kleinen und nachvollziehbaren Schritten vorzugehen. Das Ziel ist das Aufbrechen stark gekoppelter Abhängigkeiten, um so neue Tests hinzufügen zu können. Zudem wird der Code besser lesbar sein und lässt sich so auch leichter warten und wiederverwenden.
      <br/><br/>
      Vorkenntnisse:
      <br/><br/>
      Die Besucher sollten Erfahrung mit Legacy-Code aus lang andauernden Projekten haben. Die Beispiele des Live-Codings sind in Java, können aber auch leicht auf andere objektorientierte Sprachen übertragen werden.
      <br/><br/>
      Lernziele:
      <br/><br/>
      Den Zuhörern wird gezeigt, wie Legacy-Code mit einfachen Mitteln, aber trotzden sicher und mit möglichst wenig Nebeneffekten refactort werden kann.
    "Funktionale Programmierung geht auch mit/trotz Java!": |
      Java ist keine funktionale Sprache, aber dank Streams und Lambdas kann man nun seit einiger Zeit auf funktionale Art und Weise programmieren. Reicht das etwa schon, um ausdrucksstärkeren und besser lesbaren Sourcecode zu entwickeln? Passt dieses Programmierparadigma überhaupt zur imperativen Denkweise von uns Java-Entwicklern?
      <br/><br/>
      Anhand eines Real-World-Szenarios machen wir uns mit den fehlenden Puzzlestücken der funktionalen Programmierung vertraut. Dabei geht es um Value Types, Pattern Matching, praktische Anwendung von Monaden (Optional, Try, Either, Validierung), Bedarfsauswertung, partielle Funktionsaufrufe, Currying, Funktionskomposition, persistente Datenstrukturen, Seiteneffektfreiheit, referentielle Transparenz und einiges mehr. Wir diskutieren Lösungsansätze in Java und werfen vor allem einen Blick auf nützliche Bibliotheken wie Immutables und Vavr. Denn erst dadurch macht funktionale Programmierung auch in Java wirklich Spass.
    "Java 9 ist tot, lang lebe Java 11 (Co-Sprecher: Steffen Schäfer, Orientation in Objects GmbH)": |
      Seit dem Release von Java 9 hat Oracle ein Rapid-Release-Modell für neue Java-Versionen etabliert. Im halbjährlichen Rhythmus kommen jetzt neue Featurereleases. Um nicht im Supportwahnsinn zu versinken, wird Oracle nur noch bestimmte Versionen langfristig unterstützen. Das erste dieser LTS-Releases ist Java 11, welches Java 8 als letztes klassisches Release mit langfristiger Unterstützung beerbt hat. Es ist also an der Zeit, dass wir Java-Entwickler uns einen Überblick über die Neuerungen der vergangenen drei Major-Releases verschaffen. Lässt man das Modulsystem (JPMS/Jigsaw) außer Acht, haben die Java-Versionen 9 bis 11 nämlich noch viele andere, spannende Änderungen mitgebracht. Neben den Sprachänderungen wie "Local Variable Type Inference" möchten wir einen genauen Blick auf die vielen kleinen Erweiterungen der JDK-Klassenbibliothek werfen.
    "Micronaut – effiziente und performante Microservices für die Cloud": |
      Den Chancen, die der Microservices-Ansatz bietet, stehen auch einige Herausforderungen gegenüber, die man aber gut mit Frameworks handhaben kann. Mit Micronaut hat nun ein ganz neuer Vertreter die Bühne mit dem Versprechen betreten, modulare, leicht testbare und sehr performante Anwendungen in Java, Kotlin oder Groovy entwickeln zu können. 
      <br/><br/>
      Auch wenn Micronaut dem Platzhirsch aus dem Spring-Ökosystem ähnlich sieht, wurde es von Grund auf explizit für die Erstellung von Microservices im Cloud-Computing-Umfeld erstellt. Dank extrem kurzer Startzeiten, einem enorm niedrigen Speicherverbrauch und sehr kleinen JAR-Größen wird es die Microservices-Welt umkrempeln. 
      <br/><br/>
      Ermöglicht wird das neuartige Programmiermodell mittels Compile-Zeit-Metaprogrammierung, wodurch die Metadaten für beispielsweise Dependency Injection und die aspektorientierte Programmierung bereits beim Kompilieren erzeugt werden. Reflection, Proxy Generierung und Data Caching zur Laufzeit entfallen dadurch. Zur Verwendung in der Cloud oder Serverless-Umgebungen gibt es zudem bereits zahlreiche fertig gestellte oder geplante Anbindungen an Service-Discovery-Dienste, Configuration Sharing, Load Balancing und Serverless Computing. 
      <br/><br/>
      Im Rahmen dieser Session wollen wir uns die Funktionsweise näher anschauen und anhand von realistischen Codebeispielen und Performancemessungen im Vergleich zu anderen JVM-basierten Microservices-Frameworks auf den Prüfstand stellen.
  old:
    "Groovy und Grails - Quo vadis?": |
      Das Jahr 2015 begann turbulent für die beiden bekanntesten Projekte aus dem Groovy Universum. Von der bisherigen "Mutter" Pivotal den Laufpass erhalten, mußte sich Groovy auch noch auf die Suche nach einem neuen Zuhause begeben und ist letztlich bei Apache fündig geworden. All diese Unsicherheiten haben die neuen Features der Releases 2.4 (Groovy) bzw. 3.0 (Grails) ziemlich in den Hintergrund gedrängt. Dabei sind die Projekte lebendiger denn je und vor allem schon längst reif für den produktiven Einsatz.
      <br/><br/>
      Wir werden uns die wichtigsten und interessantesten Neuerungen der vergangenen Releases anschauen und natürlich auch einen Ausblick auf die Zukunft und Roadmaps wagen.
    "WildFly Swarm - Java EE in one JAR": |
      Microservice Architekturen können mit klassischen Application Servern nichts anfangen. Stattdessen geht der Trend hin zu Fat-JARs und Self-Contained-Systems, in denen die Anwendungen ihre  Ablaufumgebung mitbringen. Nach dem Erfolg von Spring Boot und Co. haben mittlerweile die klassischen Java EE Applikationsserver-Hersteller ebenfalls Microservice-Frameworks im Angebot. In dieser Session wollen wir uns anschauen, wie mit WildFly Swarm die notwendigen Teile des WildFly AS und alle benötigten Bibliotheken mitsamt der Applikation in einem ausführbaren JAR verpackt werden. Dazu diskutieren wir natürlich auch die für Microservices relevanten Themen wie Konfiguration, Logging, Monitoring, Resilience und Service Discovery im Umfeld von WildFly Swarm. Als Abschluss wagen wir noch einen Ausblick auf Standardisierungsversuche im Rahmen von Java EE und der Microprofile-Initiative.
      