bio: Falk Sippach hat über 20 Jahre Erfahrung mit Java und ist in Mannheim bei OIO - den Java-Experten der Trivadis - als Trainer, Software-Entwickler und Architekt tätig. Er publiziert regelmäßig in Blogs, Fachartikeln und auf Konferenzen. In seiner Wahlheimat Darmstadt organisiert er mit Anderen die örtliche Java User Group. Falk twittert unter @sippsack. 
bio_en: Falk Sippach has over 20 years of experience with Java and works in Mannheim as a trainer, software developer and architect for OIO - the Java experts at Trivadis. He regularly publishes in blogs, professional articles and at conferences. In his adopted home Darmstadt he organizes the local Java User Group together with others. Falk twitters under @sippsack.
links:
  Homepage: http://www.sippsack.de
  Blog: https://blog.oio.de/author/sippsack/
  Twitter: https://twitter.com/sippsack
  GitHub: https://github.com/sippsack
  Xing: https://www.xing.com/profile/Falk_Sippach
  LinkedIn: https://www.linkedin.com/in/falk-sippach-845259114/
photos:
  "400 px": /images/falk_sippach-400px.jpg
  "300 dpi": /images/falk_sippach-300dpi.jpg
activities: 
  - event: Java User Group Darmstadt
    activity: Co-Organisator
    link: http://www.jug-da.de/about/
    since: 2013
  - event: Javaland
    activity: Programmkomitee 
    link: http://www.javaland.eu/
    since: 2013
  - event: Entwicklertag Frankfurt
    activity: Unterstützung Programmbeirat 
    link: https://entwicklertag.de
    since: 2014
  - event: DukeCon
    activity: Mitgründer und Comitter 
    link: http://dukecon.org/
    since: 2015
  - event: Herbstcampus
    activity: Programmkomitee 
    link: https://www.herbstcampus.de/konferenz_programmkomitee.php
    since: 2016
  - event: JAX
    activity: Mitglied im Advisory Board
    link: http://www.jax.de/
    since: 2016
  - event: IT-Tage
    activity: Mitglied im Kuratorium
    link: https://www.ittage.informatik-aktuell.de/konferenz/kuratorium/
    since: 2017
  - event: OOP
    activity: Bewerter für die Einreichungen
    link: https://www.oop-konferenz.de/oop2019/programm/reviewer.html
    since: 2018
talks:
  current:
    "Oje, Java ist nicht mehr kostenlos – und nun? (2019)": |
      Oracle hat sein Lizenzmodell geändert, ab JDK 11 kann es in Produktion nicht mehr kostenfrei eingesetzt werden. Seit Januar 2019 gibt es zudem keine freien Updates mehr für das momentan noch viel genutzte Oracle JDK 8. Was sind die Alternativen und wann ergibt der Einsatz welcher JDK-Version Sinn? Wir werfen einen Blick auf die Kosten für das Oracle JDK, auf die Preismodelle von anderen kommerziellen Anbietern wie Azul, IBM und RedHat sowie auf die freien Versionen Oracle OpenJDK, AdoptOpenJDK, Amazon Correto, Alibaba Dragonwell und SapMachine. Zudem werden wir uns die Alternative JVM Eclipse OpenJ9 anschauen, die für gewisse Szenarien Performancevorteile gegenüber der Hotspot Java Virtual Machine von Oracle verspricht. Wir diskutieren weiterhin, ob man bei Java 8 bleiben oder auf 11 bzw. das aktuellste JDK-Release wechseln sollte und welche Konsequenzen das mit sich bringt. Dazu werfen wir natürlich auch einen Blick auf die Neuerungen von JDK 9 bis 13 und besprechen Migrationspfade und Updatestrategien.
    "Einführung in die funktionale Programmierung mit Java (2019)": |
      Funktionale Programmierung ist im Moment in aller Munde. Seit Version 8 und Lambdas/Streams stehen auch Java-Anwendern diverse Werkzeuge zur Verfügung. Daher wird es Zeit, sich mit den grundlegenden Konzepten der funktionalen Programmierung auseinanderzusetzen.
      <br/><br/>
      Nach diesem Vortrag wirst Du verstehen, was eine pure Funktion ist und warum referentielle Transparenz bzw. Seiteneffektfreiheit wichtige Konzepte sind. Wir schauen zudem auf Value Types und wie funktionale Datenstrukturen aufgebaut sind und wie man dank Bedarfsauswertung auch mit sehr großen Datenmengen effizient umgehen kann. Weiterhin besprechen wir die Elemente der Wiederverwendung wie Funktionskomposition, Currying, partielle Funktionsaufrufe und Funktionen höherer Ordnung. Abschließend werfen wir noch ein Blick auf die Destrukturierung von Datenstrukturen mittels Pattern Matching, das Kapseln von Seiteneffekten und wie man in seiner Softwarearchitektur einen funktionalen Kern umsetzt.
    "Learning by teaching, speaking and blogging (2019)": |
      ... und wie wir als netten Nebeneffekt die Kunden dazu bringen, bei uns anzurufen.
      <br/><br/>
      In der Trivadis Location Mannheim (OIO) gehört die stetige Weiterbildung zu den Kernaufgaben aller technischen Mitarbeiter. Das Ziel ist dabei nicht nur, den Kollegen die Möglichkeit des Wissensaufbaus und -austauschs zu ermöglichen. Vielmehr wollen wir uns mit den Ergebnissen in Form von Artikeln, Blog-Posts, Vorträgen und Schulungen gegenüber unseren bestehenden und vor allem auch potentiellen neuen Kunden präsentieren. Zudem zeigen wir, dass wir uns mit modernen Technologien und Konzepten beschäftigen und als Dienstleister einen erheblichen Mehrwert schaffen können.
      <br/><br/>
      Leider haben wir nur begrenzte Ressourcen und sollten uns zudem auf die Kernthemen fokussieren, für die wir uns letztlich auch neue Kundenprojekte wünschen. Darum müssen wir inhaltlich in Form von Leitplanken Grenzen setzen. Zudem braucht es Messinstrumente, um die Weiterbildungsmaßnahmen zu koordinieren und den Kollegen gegenüber den Verpflichtungen im Projekt den Rücken freizuhalten bzw. die Ergebnisse einsammeln zu können. Dazu arbeiten wir eng mit Marketing, Vertrieb und der Disposition zusammen.
    "Domain Driven Design für Dummies (2019)": |
      Auch wenn das gleichnamige Buch von Eric Evans bereits 2003 erschienen ist, so ist Domain Driven Design gerade wieder hoch aktuell und nicht zuletzt durch den Trend zu Microservices Architekturen immer noch sehr relevant. Ziel von DDD ist die möglichst realitätsnahe Abbildung der Fachlichkeit und des Domainwissens in der Software. Das Entwickeln einer gemeinsamen domänengetriebenen Fachsprache hilft bei der Überbrückung von Kommunikationsproblemen zwischen den Fachanwendern und den Softwareentwicklern. 
      <br/><br/>
      In diesem Vortrag wollen wir einen Blick auf die Konzepte und Muster wie Context Mapping, Bounded Contexts, Domain Events und die internen Building Blocks wie Aggregate, Entities, Value Objects, Repositories usw. werfen. Das Ziel ist die Erstellung einer qualitativ hochwertigen Software mit einer einheitlichen und ausdrucksstarken Architektur. 
    "Ich möchte auch mal einen Vortrag halten - Wo fange ich bloß an? (2019)": |
      Vor einer Gruppe von Menschen einen Vortrag zu halten, ist für viele von uns eine große Hürde. Mit der richtigen Vorbereitung und etwas Übung muss das aber gar kein Problem sein und ist gerade für den beruflichen Alltag sehr nützlich. Und auch wenn es paradox klingt, bieten User Groups und Konferenzen die besten Voraussetzungen, sich mal vor Publikum auszuprobieren. Aber wie findet man ein spannendes Thema, wie schreibt man einen interessanten Abstract, wie sieht die Vorbereitung aus, wenn man angenommen wurde und was sind die besten Tricks, um auf der Bühne eine gute Figur zu machen? Ich möchte Euch von meinen Erfahrungen als Sprecher und auch Konferenz- und User Group Organisator berichten und bin mir sicher, einige zu animieren. "Nachbetreuung" ist übrigens kostenfrei und inklusive.
    "Micronaut – effiziente und performante Microservices für die Cloud (2019)": |
      Den Chancen, die der Microservices-Ansatz bietet, stehen auch einige Herausforderungen gegenüber, die man aber gut mit Frameworks handhaben kann. Mit Micronaut hat nun ein ganz neuer Vertreter die Bühne mit dem Versprechen betreten, modulare, leicht testbare und sehr performante Anwendungen in Java, Kotlin oder Groovy entwickeln zu können. 
      <br/><br/>
      Auch wenn Micronaut dem Platzhirsch aus dem Spring-Ökosystem ähnlich sieht, wurde es von Grund auf explizit für die Erstellung von Microservices im Cloud-Computing-Umfeld erstellt. Dank extrem kurzer Startzeiten, einem enorm niedrigen Speicherverbrauch und sehr kleinen JAR-Größen wird es die Microservices-Welt umkrempeln. 
      <br/><br/>
      Ermöglicht wird das neuartige Programmiermodell mittels Compile-Zeit-Metaprogrammierung, wodurch die Metadaten für beispielsweise Dependency Injection und die aspektorientierte Programmierung bereits beim Kompilieren erzeugt werden. Reflection, Proxy Generierung und Data Caching zur Laufzeit entfallen dadurch. Zur Verwendung in der Cloud oder Serverless-Umgebungen gibt es zudem bereits zahlreiche fertig gestellte oder geplante Anbindungen an Service-Discovery-Dienste, Configuration Sharing, Load Balancing und Serverless Computing. 
      <br/><br/>
      Im Rahmen dieser Session wollen wir uns die Funktionsweise näher anschauen und anhand von realistischen Codebeispielen und Performancemessungen im Vergleich zu anderen JVM-basierten Microservices-Frameworks auf den Prüfstand stellen.
    "Funktionale Programmierung geht auch mit/trotz Java! (2018)": |
      Java ist keine funktionale Sprache, aber dank Streams und Lambdas kann man nun seit einiger Zeit auf funktionale Art und Weise programmieren. Reicht das etwa schon, um ausdrucksstärkeren und besser lesbaren Sourcecode zu entwickeln? Passt dieses Programmierparadigma überhaupt zur imperativen Denkweise von uns Java-Entwicklern?
      <br/><br/>
      Anhand eines Real-World-Szenarios machen wir uns mit den fehlenden Puzzlestücken der funktionalen Programmierung vertraut. Dabei geht es um Value Types, Pattern Matching, praktische Anwendung von Monaden (Optional, Try, Either, Validierung), Bedarfsauswertung, partielle Funktionsaufrufe, Currying, Funktionskomposition, persistente Datenstrukturen, Seiteneffektfreiheit, referentielle Transparenz und einiges mehr. Wir diskutieren Lösungsansätze in Java und werfen vor allem einen Blick auf nützliche Bibliotheken wie Immutables und Vavr. Denn erst dadurch macht funktionale Programmierung auch in Java wirklich Spass.
    "Refactoring mit der Mikado-Methode (2018)": |
      Viele von uns haben tagtäglich mit Legacy-Code zu tun. Mal eben schnell etwas umzubauen, scheitert typischerweise an den fehlenden Tests, zudem ist der Quellcode oft überhaupt schlecht testbar.
      <br/><br/>
      In diesem Vortrag wird anhand von praktischen Codebeispielen gezeigt, wie man zunächst ein automatisiertes Sicherheitsnetz aufspannt. Anschließend werden komplexere Refactorings durchgeführt, ohne jedoch zu viele Baustellen gleichzeitig aufzureißen. Die Mikado-Methode hilft dabei, den Überblick zu behalten und in möglichst kleinen und nachvollziehbaren Schritten vorzugehen. Das Ziel ist das Aufbrechen stark gekoppelter Abhängigkeiten, um so neue Tests hinzufügen zu können. Zudem wird der Code besser lesbar sein und lässt sich so auch leichter warten und wiederverwenden.
      <br/><br/>
      Vorkenntnisse:
      <br/><br/>
      Die Besucher sollten Erfahrung mit Legacy-Code aus lang andauernden Projekten haben. Die Beispiele des Live-Codings sind in Java, können aber auch leicht auf andere objektorientierte Sprachen übertragen werden.
      <br/><br/>
      Lernziele:
      <br/><br/>
      Den Zuhörern wird gezeigt, wie Legacy-Code mit einfachen Mitteln, aber trotzden sicher und mit möglichst wenig Nebeneffekten refactort werden kann.
    "Vue.js - Neuer Stern am Framework-Himmel (2018)": |
      Im Schatten von Angular und React hat sich mit Vue.js ein weiteres JavaScript Webframework als ernstzunehmende Alternative zur Erstellung von modularen Single Page Applications entwickelt. Der Einstieg ist dank des einfachen und minimalen Kerns einfach, durch die hohe Anpassungsfähigkeit und das weniger dogmenbehaftete Programmiermodell bietet es aber viele Möglichkeiten für die Erstellung flexibler und performanter Webanwendungen. In diesem Vortrag werden wir am Beispiel eines Konferenzplanners die Konzepte von Vue.js diskutieren.
    "Docs as Code – Architekturdokumentation leicht gemacht (Co-Sprecher: Ralf D. Müller, Freiberufler, 2018)": |
      Technische Dokumentation sollte man nicht mit Textverarbeitungsprogrammen erzeugen. Stattdessen ergibt es Sinn, die Erstellung in die normalen Entwicklungsprozesse einzubeziehen, sie zu automatisieren (Continuous Documentation) und mit den typischen Werkzeugen der Entwickler sowie mittels leichtgewichtigen Textformaten zu bearbeiten (Documentation as Code).
      <br/><br/>
      Anhand einer Architekturdokumentation zeigen wir, wie Sie mit dem arc42-Template im AsciiDoc-Format und Gradle als Build-Tool einfach Diagramme in Ihre Dokumentation integrieren, Stakeholder-spezifische Dokumente erzeugen und verschiedene Ausgabeformate generieren. Reviewfähige PDF-Dokumente? Publishing nach Confluence? Integration einer Präsentation? Alles kein Problem! Einige Teile der Doku können Sie sogar automatisiert testen. Zwischendurch bekommen Sie zahlreiche Tipps, wie und wo Sie systematisch den Aufwand für Dokumentation reduzieren können und trotzdem lesbare, verständliche und praxistaugliche Ergebnisse produzieren. Dokumentieren soll endlich auch Spaß machen.
    "PWA: Portable Webanwendungen statt nativer Apps (2018)": |
      Mobile First war gestern, Offline First heißt die neue Devise. Mit diesem Credo kommen Progressive Web Apps (PWA) nicht nur sehr nahe an native Smartphone Applikationen heran, sie erhöhen vor allem die User Experience bei fehlender oder sehr schlechter Internetverbindung und müssen nicht mehr über App Stores ausgeliefert werden. Anhand einer Beispielapplikation werden wir die Grundkonzepte wie Service Worker, Application Shell, Caching und Push Notifications diskutieren und einen Ausblick auf die mobilen Anwendungen der Zukunft werfen.
    "TDLCR - Test Driven Legacy Code Refactoring (2016)": |
      Bestandsanwendungen müssen gewartet und ggf. weiterentwickelt werden, bergen aber meist viele Defekte. Als Entwickler fürchten wir uns zudem, mehr Schaden anzurichten, weil das Verständnis für den Legacy Code fehlt. Refactoring kann zum Verstehen beitragen, endet aber aufgrund der typischerweise fehlenden automatisierten Tests in einem Blindflug.
      <br/><br/>
      Mit testgetriebener Entwicklung scheint es eine Allzweckwaffe für gutes Design und eine geringe Fehlerrate zu geben. Aber TDD und Legacy Code schließen sich eigentlich aus. Anhand von Live Coding schauen wir, wie die testgetriebene Entwicklung trotzdem helfen kann, den Code ohne allzu große Bauchschmerzen anzupassen. Schöner Nebeneffekt wird das Entstehen eines automatisierten Testbetts sein, welches zukünftige Refactorings leichter macht.    
    "JVM Functional Language Battle (2016)": |
      Funktionale Programmierung soll so viel ausdrucksstärker sein, aber leider ist dieses Programmier-Paradigma nicht ganz kompatibel zu der prozedural- und objektorientierten Denkweise von uns Java-Entwicklern. Anhand eines kleinen Algorithmus werden wir uns verschiedene Lösungen zunächst im klassischem imperativen Java (vor Java 8) und als Vergleich dazu in alternativen JVM-Sprachen (Groovy, JavaScript, Scala und Frege/Haskell) anschauen und die verschiedenen Lösungen diskutieren. Herauskommen soll eine saubere und verständlichere Struktur, die zu besser les- und wartbarem Code führen wird.
      <br/><br/>
      Die gewonnenen Erkenntnisse wollen wir dann letztendlich in Java 8 mittels Streams und Lambda-Ausdrücken umsetzen, so dass jeder Zuhörer die Grundideen der funktionalen Programmierung mit in seine tägliche Arbeit nehmen kann. Es sind keine speziellen Vorkenntnisse in den angesprochenen alternativen Sprachen notwendig, ein solides Verständnis für die Programmiersprache Java genügt.
    "Kontinuierliche Architekturdokumentation im agilen Umfeld (2016)": |
      Man kann zwar an vielen Stellen nachlesen, wie man Architekturdokumentation strukturiert. Aber auf der Suche nach einer praktikablen Handhabung zur Erstellung und Pflege enden die meisten Versuche in der WYSIWYG-Hölle einer Textverarbeitung oder im tiefen Schlund eines Wikis. In diesem Vortrag wollen wir uns anschauen, wie aufbauend auf bestehenden Tools und Textformaten eine möglichst redundanzfreie Dokumentation erstellt und für verschiedene Zielgruppen in ansprechenden Formaten ausgeliefert werden kann. Es wird dabei um Begriffe wie Continuous Documentation und Documentation as Code gehen.
    "Legacy Code meistern in x einfachen Schritten (2015)": |
      In einer idealen Welt würden wir nur "neuen" Code schreiben, der natürlich perfekt und wunderschön ist. Wir müßten nie wieder unseren Code anschauen geschweige denn 10 Jahre alte Projekte warten. Ende des Tagtraums ... 
      <br/><br/>
      Leider ist unsere Welt nicht so ideal, unser Code von gestern ist heute schon Legacy. Diesen im Nachhinein zu verstehen, zu erweitern oder darin Fehler zu beheben ist immer eine Herausforderung, insbesondere wenn Tests fehlen.Trotzdem gibt es einfache Möglichkeiten, wie man die Qualität von Legacy Code verbessern kann. Das Wichtigste ist das Einziehen von Fangnetzen, so daß man trotz fehlender Tests guten Gewissens Änderungen durchführen kann. Wer Golden Master, Subclass to Test und Extract Pure Functions an konkreten Beispielen kennenlernen möchte, ist in dieser Session genau richtig.
  old:
    "Java 9 ist tot, lang lebe Java 11 (Co-Sprecher: Steffen Schäfer, Orientation in Objects GmbH, 2018)": |
      Seit dem Release von Java 9 hat Oracle ein Rapid-Release-Modell für neue Java-Versionen etabliert. Im halbjährlichen Rhythmus kommen jetzt neue Featurereleases. Um nicht im Supportwahnsinn zu versinken, wird Oracle nur noch bestimmte Versionen langfristig unterstützen. Das erste dieser LTS-Releases ist Java 11, welches Java 8 als letztes klassisches Release mit langfristiger Unterstützung beerbt hat. Es ist also an der Zeit, dass wir Java-Entwickler uns einen Überblick über die Neuerungen der vergangenen drei Major-Releases verschaffen. Lässt man das Modulsystem (JPMS/Jigsaw) außer Acht, haben die Java-Versionen 9 bis 11 nämlich noch viele andere, spannende Änderungen mitgebracht. Neben den Sprachänderungen wie "Local Variable Type Inference" möchten wir einen genauen Blick auf die vielen kleinen Erweiterungen der JDK-Klassenbibliothek werfen.
    "Agile Architecture (Co-Sprecher: Thorsten Maier, Orientation in Objects GmbH, 2017)": |
      Eine gut geplante Software-Architektur stellt das Grundgerüst jeder wartbaren Software dar. Dies steht in einem scheinbaren Widerspruch zu agilen Softwareprozessen, bei denen langfristige Planungen weitestgehend vermieden werden. Die Session zeigt anhand zahlreicher konkreter Beispiele, wie man die Erstellung einer Software-Architektur in einzelne Aufgabenpakete unterteilt, dokumentiert und regelmäßig durch Reviews und automatisierte Architektur-Tests verifiziert. Das Ziel ist es, auch in einem iterativen Prozess eine langfristig tragfähige Architektur entstehen zu lassen.
      <br/><br/>
      Anmerkungen fürs Programmkomitee:
      <br/><br/>
      In diesem Vortrag liefern wir praktische Tipps, wie man eine tragfähige Architektur im Rahmen iterativer Prozesse einführt, pflegt und weiterentwickelt. Wir haben dazu nach dem Verfahren "Plan, Do, Check, Act" einzelne Aspekte des Architektur-Entwurfs, -Bewertung, -Kommunikation, -Tests usw. zusammengefasst und stellen diese mit unseren Erfahrungen aus der Praxis vor.
    "WildFly Swarm - Java EE in one JAR (2017)": |
      Microservice Architekturen können mit klassischen Application Servern nichts anfangen. Stattdessen geht der Trend hin zu Fat-JARs und Self-Contained-Systems, in denen die Anwendungen ihre  Ablaufumgebung mitbringen. Nach dem Erfolg von Spring Boot und Co. haben mittlerweile die klassischen Java EE Applikationsserver-Hersteller ebenfalls Microservice-Frameworks im Angebot. In dieser Session wollen wir uns anschauen, wie mit WildFly Swarm die notwendigen Teile des WildFly AS und alle benötigten Bibliotheken mitsamt der Applikation in einem ausführbaren JAR verpackt werden. Dazu diskutieren wir natürlich auch die für Microservices relevanten Themen wie Konfiguration, Logging, Monitoring, Resilience und Service Discovery im Umfeld von WildFly Swarm. Als Abschluss wagen wir noch einen Ausblick auf Standardisierungsversuche im Rahmen von Java EE und der Microprofile-Initiative.
    "Groovy und Grails - Quo vadis? (2015)": |
      Das Jahr 2015 begann turbulent für die beiden bekanntesten Projekte aus dem Groovy Universum. Von der bisherigen "Mutter" Pivotal den Laufpass erhalten, mußte sich Groovy auch noch auf die Suche nach einem neuen Zuhause begeben und ist letztlich bei Apache fündig geworden. All diese Unsicherheiten haben die neuen Features der Releases 2.4 (Groovy) bzw. 3.0 (Grails) ziemlich in den Hintergrund gedrängt. Dabei sind die Projekte lebendiger denn je und vor allem schon längst reif für den produktiven Einsatz.
      <br/><br/>
      Wir werden uns die wichtigsten und interessantesten Neuerungen der vergangenen Releases anschauen und natürlich auch einen Ausblick auf die Zukunft und Roadmaps wagen.
    "Kontinuierliche Architektur im Rahmen grosser Agiler Projekte (Co-Sprecher: Dirk Sohn, Orientation in Objects GmbH, 2014)": |
      Der von Dean Leffingwell initiierte Methodenrahmen Scaled Agile Framework ist ein in der Agilen Szene durchaus kontrovers diskutierter Vorschlag, Software-Architektur in einen skalierbaren und doch agilen Prozess einzubinden. Wo wird eine solche beim reinen Scrum überflüssige Thematik notwendig? Welche Verantwortung trägt sie in Bilde des SAFe? Welche Charaktere sind hierfür gefragt? Wir glauben, dass einige dieser Antworten für alle größeren Entwicklungsvorhaben von Interesse sein können und berichten auch aus der Umsetzung.
    "Die Google Collections Library (2009)": |
      Die Google Collections Library ergänzt das beliebte Collections Framework um wichtige neue Datenstrukturen wie BiMap oder Multimap. Darüberhinaus enthält es diverse Utility Klassen, die gängige "Programmieraufgaben im kleinen" kompakter und damit lesbarer machen. Der Vortrag stellt die wichtigsten Datenstrukturen vor und zeigt anhand von Beispielen die Nützlichkeit der Utility Klassen.
    "GANT - Ant the groovy way (2009)": |
      Mit GANT hat man die Möglichkeit, Ant Tasks in Groovy anstatt in XML zu formulieren. Dabei hat man den vollen Zugriff auf Groovys dynamische Features und kann somit schneller und einfacher komplexes Build-Management durchführen. In diesem Short Talk wird in den Gebrauch von GANT anhand von nachvollziehbaren Beispielen eingeführt.
    "Performance Tuning bei komplexen Domainmodellen (Co-Sprecher: Christian Dedek, Orientation in Objects GmbH, 2008)": |
      Auch wenn mit Spring/Hibernate eine ausgereifte Kombination für die Realisierung komplexer persistenter Domainmodelle zum Einsatz kommt, garantiert dies nicht automatisch 100%ige Anwenderzufriedenheit. Der Vortrag diskutiert typische Performanceprobleme stark hierarchisierter Datenmodelle mit verzweigten Objektgrafen und zyklischen Abhängigkeiten und stellt deren Lösungsmöglichkeiten vor.
    "Groovy und Grails (Co-Sprecher: Sönke Sothmann, Orientation in Objects GmbH, 2007)": |
      Groovy ist eine dynamische Sprache für die Java Plattform. Sie ist Java ähnlich, bietet jedoch eine ausdrucksstärkere Syntax. Grails ist ein auf Groovy basierendes Webframework. Es nutzt die dynamischen Features von Groovy und setzt auf etablierten Java Enterprise Frameworks auf. Die Session stellt die beiden Technologien vor und zeigt, für welche Problemstellungen sich ein Einsatz lohnt.
workshops:
  2020:
    - title: Property Based Resilience Testing Workshop
      abstract: |
        Property Based Resilience Testing ist die Kombination von Resilience Testing und Property Based Testing. Resilienztests bestimmen den Umfang der Fähigkeit eines Systems, bei Störungen oder Teilausfällen nicht vollständig zu versagen. Property Based Testing hilft bei der Erstellung zufälliger Testpläne, bei deren Ausführung darauf geachtet wird, dass bestimmte Verhaltenseigenschaften bestehen bleiben. In diesem Workshop für Anfänger und Fortgeschrittene zeigen wir euch, wie sich Container-basierte Systeme damit testen lassen.
      length: 3 h 
      co-speaker: Gregor Trefs (majug)
    - title: Workshop zu Kotlin/Native und Multiplatform
      abstract: |
        Wir bauen gemeinsam eine auf der DukeCon Kotlin Native Library basierende App, die das Vortragsprogramm der JavaLand anzeigen kann. Hier lernt ihr Kotlin/Native und Kotlin Multiplatform kennen und erfahrt, wie man eine KLib baut, sie konsumiert und auf unterschiedlichen Zielplattformen einsetzt.
        <br/><br/>
        Voraussetzungen:<br/>
        Ein Laptop mit IDE nach Wahl (IntelliJ, Eclipse etc.) und Android Studio, Android SDK, Emulator/Smartphone oder Apple Mac mit XCode.
      length: 2 h
      co-speaker: Michal Harakal (Deutsche Telekom AG)
    - title: "Entwicklung einer verteilten Anwendung auf Kubernetes (Hands On)"
      abstract: |
        Wir stellen euch ein Entwicklungs- und Betriebsmodell unter Kubernetes anhand des DukeCon-JavaLand-Konferenzplaners vor. In kleinen Gruppen habt ihr dabei die Möglichkeit, euch selbst damit vertraut zu machen und DukeCon eigenhändig auf einem Kubernetes-Cluster aufzubauen.
      length: 2 h bis 1 Tag
      co-speaker: DukeCon Team
  2019:
    - title: Einführung in die Funktionale Programmierung mit Java
      abstract: |
        Funktionale Programmierung ist im Moment in aller Mund. Seit Java 8 und Lambdas stehen auch Java-Anwendern einige Werkzeuge zur Verfügung, um funktionale Anwendungen komfortabler umzusetzen. Darum wollen wir uns mit einigen Grundlagen der funktionalen Programmierung auseinandersetzen und schauen, wie man sie in Java einsetzen kann.
        <br/><br/>
        Nach diesem Workshop wirst du wissen, was eine pure Funktion ist, warum referentielle Transparenz ein tolles Konzept ist, was Werte sind, wie ein funktionales Programm ausgewertet werden kann und was funktionale Datenstrukturen sind. Weiterhin schauen wir uns an, wie man eine funktionale DSL schreiben kann und warum das auch für den Alltag sehr interessant ist. Um am Workshop teilnehmen zu können, braucht man einen Laptop mit Java >= 8 und einen Editor seiner Wahl.
        <br/><br/>
        Bitte beachten: Diese Einführung ist nicht allumfassend, und es werden Fragen offen bleiben. Aber wir geben Hinweise auf weiterführende Informationen und Online-Kurse.
        <br/><br/>
        Voraussetzungen: Laptop mit mind. Java 8 und IDE der Wahl
      length: 3 h 
      co-speaker: Gregor Trefs (majug)
  2018:
    - title: Refactoring von Legacy Anwendungen mit der Mikado-Methode
      abstract: |
        "Das refactore ich mal eben!", denkt man sich, nur um zehn Minuten später etliche Baustellen gleichzeitig aufgerissen zu haben, die man gar nicht vorhergesehen hat. Das ist oft das Ende gut gemeinter Aufräumaktionen. Wie kann die Mikado-Methode in solchen Situationen helfen? Wie gelingt es, den Überblick zu behalten und möglichst kleine und nachvollziehbare Schritte zu machen? Diese und andere Fragen werden in diesem Workshop beantwortet.
      length: 2 h
      co-speaker: Steven Schwenke (msg DAVID GmbH)
  2017:
    - title: Legacy Code Retreat
      abstract: |
        Ziel eines Legacy Code Retreat ist es, den Umgang mit dem Albtraum eines jeden Entwicklers (aka Legacy Code) in einer Umgebung zu üben, in der Fehler nicht den Kopf kosten. Also mal ohne Druck arbeiten und sich Zeit zum Ausprobieren von Alternativen lassen. Außerdem natürlich aktiven Austausch mit anderen Softwareentwicklern betreiben.
        <br/><br/>
        Arbeitsobjekt wird eine liebevoll kaputt-gecodete Variante des Trivia-Spiels sein (https://github.com/jbrains/trivia). Die Programmiersprache kann dabei aus dem Portfolio der JVM-Sprachen frei gewählt werden.
        <br/><br/>
        Voraussetzungen: Java 8, evtl. andere JVM-Sprachen, IDE (Eclipse, IntelliJ IDEA, NetBeans)
      length: 2 h - 1 Tag
      co-speaker: Steven Schwenke (msg DAVID GmbH)
  2016: 
    - title: Architektur Kata
      abstract: |
        Architekten bekommen in ihrem Arbeitsleben in der Summe typischerweise nur eine Handvoll Möglichkeiten, eine komplette Softwarearchitektur zu entwerfen. Damit hat man nur wenige Versuche, ein guter Architekt zu werden. Architektonische Trockenübungen können helfen, ohne große Konsequenzen Erfahrungen zu sammeln und sich außerdem mit Gleichgesinnten auszutauschen.
        <br/><br/>
        Das Ziel einer "Architectural Kata" ist die praktische Einführung in den Entwurf einer Softwarearchitektur anhand einer vorgegebenen Problemstellung. Es wird dabei in kleinen Gruppen gearbeitet. Um sinnvolle Lösungsvorschläge machen zu können, gilt es zunächst die richtigen Fragen an die Stakeholder zu stellen und daraus die nötigen Schlüsse zu ziehen. Die Übungen schließen mit Feedbackrunden ab, wo die Entwürfe der verschiedenen Gruppen vorgestellt und ausgewertet werden. Die geschlossenen Kompromisse und Entscheidungen müssen dafür für alle in einer nachvollziehbaren Form kommuniziert werden.
      length: 2 h
      co-speaker: Niko Köbler (Freiberufler)
  2014:
    - title: Coding Dojo
      abstract: |
        Für den beruflichen Alltag ist es wichtig, sich ständig fortzubilden und seine Fertigkeiten zu trainieren. Mit Code Katas wollen wir in kleinen Teams überschaubare Programmieraufgaben lösen und dabei voneinander lernen. Dabei zählt weniger das Ergebnis, vielmehr ist der Weg das Ziel.
      length: 2 Stunden bis 1 Tag
      co-speaker: Diverse
